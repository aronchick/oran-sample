---
name: oran-sample-pipeline
type: pipeline
config:
  input:
    generate:
      interval: 1s
      mapping: |
        root = {}
        root.node_id = "du-sno-worker-0" + (count("nodes") % 3).string()
        root.timestamp = now()

        # Simulating OpenShift Node Status
        root.status = {
          "role": "master,worker",
          "profile": "ran-du-profile-v4.20"
        }

        # Simulating Critical PTP (Precision Time Protocol) Telemetry
        # RAN DUs require extremely tight sync (often < 100ns)
        # We now simulate both the NIC clock (ptp4l) and System Clock (phc2sys)
        root.telemetry = {
          "ptp_status": {
            # Fix: random_int min must be positive. Generating 0-200 then subtracting 50 gives range -50 to 150.
            "ptp4l_offset_ns": random_int(min: 0, max: 200) - 50,
            "phc2sys_offset_ns": random_int(min: 0, max: 60) - 30,
            "lock_state": ["LOCKED", "LOCKED", "LOCKED", "HOLDOVER"].index(random_int(max: 3)),
            "clock_class": 6,
            "gm_identity": "0x4857ddfffe0" + random_int(max:999).string()
          },
          "interfaces": [
            {
              "name": "ens1f0",
              "type": "sriov",
              "numa_node": 0,
              "rx_packets": random_int(min: 100000, max: 500000),
              "dropped": random_int(max: 5),
              "sfp_status": { "temperature_c": 45 + random_int(max: 5), "tx_power_dbm": -2.5, "rx_power_dbm": -3.1 }
            },
            {
              "name": "ens1f1",
              "type": "sriov",
              "numa_node": 0,
              "rx_packets": random_int(min: 100000, max: 500000),
              "dropped": 0,
              "sfp_status": { "temperature_c": 44 + random_int(max: 5), "tx_power_dbm": -2.4, "rx_power_dbm": -3.0 }
            }
          ],
          "accelerators": [
            { "type": "fec_acc100", "device": "pci_0000_00_00.1", "queue_depth": random_int(max: 128), "utilization_pct": random_int(min: 20, max: 80) }
          ],
          "compute": {
            "isolated_cores": [2,3,4,5,6,7],
            "reserved_cores": [0,1],
            "rt_kernel_active": true
          }
        }

  pipeline:
    processors:
      # -----------------------------------------------------------
      # BLOBLANG MAPPING FOR ORAN DATA NORMALIZATION
      # -----------------------------------------------------------
      - bloblang: |
          # 1. Metadata Enrichment
          meta "ingest_time" = now()
          meta "source_profile" = this.status.profile

          # 2. Flatten Core Structure for downstream analytics
          root.du_id = this.node_id.uppercase()
          root.event_time = this.timestamp

          # 3. PTP Compliance Check (Critical for RAN)
          # Red Hat RAN specs require tight PTP sync. We flag violations.
          let ptp_offset = this.telemetry.ptp_status.ptp4l_offset_ns
          let sys_offset = this.telemetry.ptp_status.phc2sys_offset_ns
          let state = this.telemetry.ptp_status.lock_state

          root.sync_health = if $state != "LOCKED" {
            "CRITICAL_UNLOCK"
          } else if $ptp_offset > 100 || $ptp_offset < -100 {
            "DEGRADED_OFFSET_HIGH"
          } else if $sys_offset > 50 || $sys_offset < -50 {
            "DEGRADED_SYS_CLOCK"
          } else {
            "HEALTHY"
          }

          root.sync_metrics = {
            "ptp_offset_ns": $ptp_offset,
            "sys_offset_ns": $sys_offset,
            "clock_class": this.telemetry.ptp_status.clock_class
          }

          # 4. Interface Normalization (SR-IOV specific)
          # Filter only for SR-IOV interfaces relevant to the Fronthaul
          root.fronthaul_stats = this.telemetry.interfaces.filter(i -> i.type == "sriov").map_each(i -> {
            "id": i.name,
            "throughput_score": i.rx_packets / 100,
            "is_clean": i.dropped == 0,
            "temp_status": if i.sfp_status.temperature_c > 70 { "HOT" } else { "OK" }
          })

          # 5. Validation against Ref Design Specs
          # Ensure Real-Time Kernel is active as per Red Hat specs
          if !this.telemetry.compute.rt_kernel_active {
            root.compliance_violation = "RT_KERNEL_MISSING"
          }

  output:
    switch:
      cases:
        # Route critical sync issues to a dedicated 'alert' file
        # FIX: Use 'this' instead of 'root' to correctly read the processed message fields
        - check: this.sync_health.contains("CRITICAL") || this.sync_health.contains("DEGRADED")
          output:
            file:
              path: "/tmp/critical.txt"
              codec: lines
            processors:
              - bloblang: |
                  root = "ALERT: DU Node %s Sync Issue: %s (Offset: %sns)".format(
                    this.du_id,
                    this.sync_health,
                    this.sync_metrics.ptp_offset_ns.string()
                  )

        # Route all normalized data to standard log file
        - check: true
          output:
            file:
              path: "/tmp/normal.txt"
              codec: lines
