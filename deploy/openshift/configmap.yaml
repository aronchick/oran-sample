---
apiVersion: v1
kind: ConfigMap
metadata:
  name: expanso-oran-pipeline
  namespace: expanso-system
  labels:
    app.kubernetes.io/name: expanso
    app.kubernetes.io/component: oran-telemetry
data:
  # OTLP endpoint configuration
  # Override these in your environment or use a Secret for auth tokens
  OTLP_ENDPOINT: "http://otel-collector.observability.svc.cluster.local:4318"
  EMIT_INTERVAL: "5s"

  pipeline.yaml: |
    ---
    name: oran-otlp-pipeline
    type: pipeline
    config:
      input:
        generate:
          interval: ${EMIT_INTERVAL:5s}
          mapping: |
            let node_name = env("NODE_NAME").or("du-sno-worker")

            root = {}
            root.node_id = $node_name + "-" + (count("nodes") % 3).string()
            root.timestamp = now()

            root.ocp_context = {
              "cluster": env("CLUSTER_NAME").or("sno-edge-01"),
              "namespace": env("POD_NAMESPACE").or("expanso-system"),
              "role": "master,worker",
              "profile": "ran-du-profile-v4.20"
            }

            root.telemetry = {
              "ptp_status": {
                "ptp4l_offset_ns": random_int(min: 0, max: 200) - 50,
                "phc2sys_offset_ns": random_int(min: 0, max: 60) - 30,
                "lock_state": ["LOCKED", "LOCKED", "LOCKED", "HOLDOVER"].index(random_int(max: 3)),
                "clock_class": 6,
                "gm_identity": "0x4857ddfffe0" + random_int(max:999).string()
              },
              "interfaces": [
                {
                  "name": "ens1f0",
                  "type": "sriov",
                  "numa_node": 0,
                  "rx_packets": random_int(min: 100000, max: 500000),
                  "tx_packets": random_int(min: 90000, max: 450000),
                  "dropped": random_int(max: 5),
                  "errors": random_int(max: 2),
                  "sfp_status": {
                    "temperature_c": 45 + random_int(max: 30),
                    "tx_power_dbm": -2.5 + (random_int(max: 10) - 5) * 0.1,
                    "rx_power_dbm": -3.1 + (random_int(max: 10) - 5) * 0.1
                  }
                },
                {
                  "name": "ens1f1",
                  "type": "sriov",
                  "numa_node": 0,
                  "rx_packets": random_int(min: 100000, max: 500000),
                  "tx_packets": random_int(min: 90000, max: 450000),
                  "dropped": 0,
                  "errors": 0,
                  "sfp_status": {
                    "temperature_c": 44 + random_int(max: 25),
                    "tx_power_dbm": -2.4,
                    "rx_power_dbm": -3.0
                  }
                }
              ],
              "accelerators": [
                {
                  "type": "fec_acc100",
                  "device": "pci_0000_00_00.1",
                  "queue_depth": random_int(max: 128),
                  "utilization_pct": random_int(min: 20, max: 80),
                  "encode_rate_mbps": random_int(min: 800, max: 1200),
                  "decode_rate_mbps": random_int(min: 750, max: 1150)
                }
              ],
              "compute": {
                "isolated_cores": [2,3,4,5,6,7],
                "reserved_cores": [0,1],
                "rt_kernel_active": true,
                "cpu_usage_pct": random_int(min: 15, max: 65)
              }
            }

      pipeline:
        processors:
          - bloblang: |
              meta "ingest_time" = now()
              meta "source_profile" = this.ocp_context.profile

              root.du_id = this.node_id.uppercase()
              root.cluster = this.ocp_context.cluster
              root.namespace = this.ocp_context.namespace
              root.event_time = this.timestamp
              root.event_time_unix_nano = this.timestamp.ts_unix_nano()

              let ptp_offset = this.telemetry.ptp_status.ptp4l_offset_ns
              let sys_offset = this.telemetry.ptp_status.phc2sys_offset_ns
              let state = this.telemetry.ptp_status.lock_state

              root.sync_health = if $state != "LOCKED" {
                "CRITICAL_UNLOCK"
              } else if $ptp_offset > 100 || $ptp_offset < -100 {
                "DEGRADED_OFFSET_HIGH"
              } else if $sys_offset > 50 || $sys_offset < -50 {
                "DEGRADED_SYS_CLOCK"
              } else {
                "HEALTHY"
              }

              root.sync_health_code = if root.sync_health == "HEALTHY" { 0 } else if root.sync_health.has_prefix("DEGRADED") { 1 } else { 2 }

              root.ptp = {
                "ptp4l_offset_ns": $ptp_offset,
                "phc2sys_offset_ns": $sys_offset,
                "lock_state": $state,
                "clock_class": this.telemetry.ptp_status.clock_class,
                "gm_identity": this.telemetry.ptp_status.gm_identity
              }

              root.interfaces = this.telemetry.interfaces
              root.accelerators = this.telemetry.accelerators
              root.compute = this.telemetry.compute

          - bloblang: |
              let ts = this.event_time_unix_nano

              let resource_attrs = [
                { "key": "service.name", "value": { "stringValue": "oran-du-telemetry" } },
                { "key": "service.namespace", "value": { "stringValue": this.namespace } },
                { "key": "k8s.cluster.name", "value": { "stringValue": this.cluster } },
                { "key": "k8s.node.name", "value": { "stringValue": this.du_id } },
                { "key": "oran.profile", "value": { "stringValue": meta("source_profile") } },
                { "key": "ptp.gm_identity", "value": { "stringValue": this.ptp.gm_identity } }
              ]

              let metrics = []

              let metrics = $metrics.append({
                "name": "oran.ptp.ptp4l_offset_ns",
                "description": "PTP4L clock offset from grandmaster in nanoseconds",
                "unit": "ns",
                "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": this.ptp.ptp4l_offset_ns.string() }] }
              })

              let metrics = $metrics.append({
                "name": "oran.ptp.phc2sys_offset_ns",
                "description": "PHC2SYS system clock offset in nanoseconds",
                "unit": "ns",
                "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": this.ptp.phc2sys_offset_ns.string() }] }
              })

              let metrics = $metrics.append({
                "name": "oran.ptp.clock_class",
                "description": "PTP clock class (6=locked to primary)",
                "unit": "1",
                "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": this.ptp.clock_class.string() }] }
              })

              let metrics = $metrics.append({
                "name": "oran.sync_health",
                "description": "Sync health status (0=healthy, 1=degraded, 2=critical)",
                "unit": "1",
                "gauge": {
                  "dataPoints": [{
                    "timeUnixNano": $ts.string(),
                    "asInt": this.sync_health_code.string(),
                    "attributes": [{ "key": "status", "value": { "stringValue": this.sync_health } }]
                  }]
                }
              })

              let metrics = this.interfaces.fold($metrics, iface -> m -> {
                let base = m.append({
                  "name": "oran.interface.rx_packets",
                  "unit": "1",
                  "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": iface.rx_packets.string(), "attributes": [{ "key": "interface", "value": { "stringValue": iface.name } }] }] }
                })
                let base = base.append({
                  "name": "oran.interface.dropped",
                  "unit": "1",
                  "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": iface.dropped.string(), "attributes": [{ "key": "interface", "value": { "stringValue": iface.name } }] }] }
                })
                let base = base.append({
                  "name": "oran.interface.sfp_temperature_c",
                  "unit": "Cel",
                  "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asDouble": iface.sfp_status.temperature_c, "attributes": [{ "key": "interface", "value": { "stringValue": iface.name } }] }] }
                })
                $base
              })

              let metrics = this.accelerators.fold($metrics, acc -> m -> {
                let base = m.append({
                  "name": "oran.fec.utilization_pct",
                  "unit": "%",
                  "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": acc.utilization_pct.string(), "attributes": [{ "key": "device", "value": { "stringValue": acc.device } }] }] }
                })
                let base = base.append({
                  "name": "oran.fec.queue_depth",
                  "unit": "1",
                  "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": acc.queue_depth.string(), "attributes": [{ "key": "device", "value": { "stringValue": acc.device } }] }] }
                })
                $base
              })

              let metrics = $metrics.append({
                "name": "oran.compute.cpu_usage_pct",
                "unit": "%",
                "gauge": { "dataPoints": [{ "timeUnixNano": $ts.string(), "asInt": this.compute.cpu_usage_pct.string() }] }
              })

              root = {
                "resourceMetrics": [{
                  "resource": { "attributes": $resource_attrs },
                  "scopeMetrics": [{
                    "scope": { "name": "expanso.oran.collector", "version": "1.0.0" },
                    "metrics": $metrics
                  }]
                }]
              }

      output:
        http_client:
          url: ${OTLP_ENDPOINT:http://localhost:4318}/v1/metrics
          verb: POST
          headers:
            Content-Type: application/json
          timeout: 5s
          retry_period: 1s
          max_retry_backoff: 30s
          retries: 3
