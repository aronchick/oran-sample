---
# O-RAN Telemetry Pipeline with OTLP Output
# Expanso + Red Hat OpenShift Integration Demo
#
# Environment Variables:
#   OTLP_ENDPOINT - OTLP HTTP endpoint (default: http://localhost:4318)
#   OTLP_HEADERS  - Optional headers as JSON (e.g., '{"Authorization":"Bearer xxx"}')
#   NODE_NAME     - OpenShift node name (default: du-sno-worker)
#   EMIT_INTERVAL - Telemetry interval (default: 5s)

name: oran-otlp-pipeline
type: pipeline
config:
  input:
    generate:
      interval: ${EMIT_INTERVAL:5s}
      mapping: |
        let node_name = env("NODE_NAME").or("du-sno-worker")

        root = {}
        root.node_id = $node_name + "-" + (count("nodes") % 3).string()
        root.timestamp = now()

        # OpenShift Node Context
        root.ocp_context = {
          "cluster": env("CLUSTER_NAME").or("sno-edge-01"),
          "namespace": env("POD_NAMESPACE").or("expanso-system"),
          "role": "master,worker",
          "profile": "ran-du-profile-v4.20"
        }

        # PTP (Precision Time Protocol) Telemetry
        # Critical for O-RAN: DUs require < 100ns sync accuracy
        root.telemetry = {
          "ptp_status": {
            "ptp4l_offset_ns": random_int(min: 0, max: 200) - 50,
            "phc2sys_offset_ns": random_int(min: 0, max: 60) - 30,
            "lock_state": ["LOCKED", "LOCKED", "LOCKED", "HOLDOVER"].index(random_int(max: 3)),
            "clock_class": 6,
            "gm_identity": "0x4857ddfffe0" + random_int(max:999).string()
          },
          "interfaces": [
            {
              "name": "ens1f0",
              "type": "sriov",
              "numa_node": 0,
              "rx_packets": random_int(min: 100000, max: 500000),
              "tx_packets": random_int(min: 90000, max: 450000),
              "dropped": random_int(max: 5),
              "errors": random_int(max: 2),
              "sfp_status": {
                "temperature_c": 45 + random_int(max: 30),
                "tx_power_dbm": -2.5 + (random_int(max: 10) - 5) * 0.1,
                "rx_power_dbm": -3.1 + (random_int(max: 10) - 5) * 0.1
              }
            },
            {
              "name": "ens1f1",
              "type": "sriov",
              "numa_node": 0,
              "rx_packets": random_int(min: 100000, max: 500000),
              "tx_packets": random_int(min: 90000, max: 450000),
              "dropped": 0,
              "errors": 0,
              "sfp_status": {
                "temperature_c": 44 + random_int(max: 25),
                "tx_power_dbm": -2.4,
                "rx_power_dbm": -3.0
              }
            }
          ],
          "accelerators": [
            {
              "type": "fec_acc100",
              "device": "pci_0000_00_00.1",
              "queue_depth": random_int(max: 128),
              "utilization_pct": random_int(min: 20, max: 80),
              "encode_rate_mbps": random_int(min: 800, max: 1200),
              "decode_rate_mbps": random_int(min: 750, max: 1150)
            }
          ],
          "compute": {
            "isolated_cores": [2,3,4,5,6,7],
            "reserved_cores": [0,1],
            "rt_kernel_active": true,
            "cpu_usage_pct": random_int(min: 15, max: 65)
          }
        }

  pipeline:
    processors:
      # Stage 1: Normalize and validate O-RAN telemetry
      - bloblang: |
          meta "ingest_time" = now()
          meta "source_profile" = this.ocp_context.profile

          root.du_id = this.node_id.uppercase()
          root.cluster = this.ocp_context.cluster
          root.namespace = this.ocp_context.namespace
          root.event_time = this.timestamp
          root.event_time_unix_nano = this.timestamp.ts_unix_nano()

          # PTP Compliance Check (Red Hat RAN Reference Design specs)
          let ptp_offset = this.telemetry.ptp_status.ptp4l_offset_ns
          let sys_offset = this.telemetry.ptp_status.phc2sys_offset_ns
          let state = this.telemetry.ptp_status.lock_state

          root.sync_health = if $state != "LOCKED" {
            "CRITICAL_UNLOCK"
          } else if $ptp_offset > 100 || $ptp_offset < -100 {
            "DEGRADED_OFFSET_HIGH"
          } else if $sys_offset > 50 || $sys_offset < -50 {
            "DEGRADED_SYS_CLOCK"
          } else {
            "HEALTHY"
          }

          root.sync_health_code = if root.sync_health == "HEALTHY" { 0 } else if root.sync_health.has_prefix("DEGRADED") { 1 } else { 2 }

          root.ptp = {
            "ptp4l_offset_ns": $ptp_offset,
            "phc2sys_offset_ns": $sys_offset,
            "lock_state": $state,
            "clock_class": this.telemetry.ptp_status.clock_class,
            "gm_identity": this.telemetry.ptp_status.gm_identity
          }

          root.interfaces = this.telemetry.interfaces
          root.accelerators = this.telemetry.accelerators
          root.compute = this.telemetry.compute

      # Stage 2: Transform to OTLP Metrics format
      - bloblang: |
          let ts = this.event_time_unix_nano

          # Resource attributes identify the O-RAN DU
          let resource_attrs = [
            { "key": "service.name", "value": { "stringValue": "oran-du-telemetry" } },
            { "key": "service.namespace", "value": { "stringValue": this.namespace } },
            { "key": "k8s.cluster.name", "value": { "stringValue": this.cluster } },
            { "key": "k8s.node.name", "value": { "stringValue": this.du_id } },
            { "key": "oran.profile", "value": { "stringValue": meta("source_profile") } },
            { "key": "ptp.gm_identity", "value": { "stringValue": this.ptp.gm_identity } }
          ]

          # Build metrics array
          let metrics = []

          # PTP Sync Metrics (critical for O-RAN)
          let metrics = $metrics.append({
            "name": "oran.ptp.ptp4l_offset_ns",
            "description": "PTP4L clock offset from grandmaster in nanoseconds",
            "unit": "ns",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": this.ptp.ptp4l_offset_ns.string()
              }]
            }
          })

          let metrics = $metrics.append({
            "name": "oran.ptp.phc2sys_offset_ns",
            "description": "PHC2SYS system clock offset in nanoseconds",
            "unit": "ns",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": this.ptp.phc2sys_offset_ns.string()
              }]
            }
          })

          let metrics = $metrics.append({
            "name": "oran.ptp.clock_class",
            "description": "PTP clock class (6=locked to primary)",
            "unit": "1",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": this.ptp.clock_class.string()
              }]
            }
          })

          let metrics = $metrics.append({
            "name": "oran.sync_health",
            "description": "Sync health status (0=healthy, 1=degraded, 2=critical)",
            "unit": "1",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": this.sync_health_code.string(),
                "attributes": [{
                  "key": "status",
                  "value": { "stringValue": this.sync_health }
                }]
              }]
            }
          })

          # Interface metrics (SR-IOV fronthaul) - ens1f0
          let iface0 = this.interfaces.index(0)
          let metrics = $metrics.append({
            "name": "oran.interface.rx_packets",
            "unit": "1",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": $iface0.rx_packets.string(),
                "attributes": [{"key": "interface", "value": {"stringValue": $iface0.name}}]
              }]
            }
          })
          let metrics = $metrics.append({
            "name": "oran.interface.sfp_temperature_c",
            "unit": "Cel",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asDouble": $iface0.sfp_status.temperature_c,
                "attributes": [{"key": "interface", "value": {"stringValue": $iface0.name}}]
              }]
            }
          })

          # Interface metrics - ens1f1
          let iface1 = this.interfaces.index(1)
          let metrics = $metrics.append({
            "name": "oran.interface.rx_packets",
            "unit": "1",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": $iface1.rx_packets.string(),
                "attributes": [{"key": "interface", "value": {"stringValue": $iface1.name}}]
              }]
            }
          })
          let metrics = $metrics.append({
            "name": "oran.interface.sfp_temperature_c",
            "unit": "Cel",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asDouble": $iface1.sfp_status.temperature_c,
                "attributes": [{"key": "interface", "value": {"stringValue": $iface1.name}}]
              }]
            }
          })

          # FEC Accelerator metrics
          let acc0 = this.accelerators.index(0)
          let metrics = $metrics.append({
            "name": "oran.fec.utilization_pct",
            "unit": "%",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": $acc0.utilization_pct.string(),
                "attributes": [{"key": "device", "value": {"stringValue": $acc0.device}}]
              }]
            }
          })
          let metrics = $metrics.append({
            "name": "oran.fec.queue_depth",
            "unit": "1",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": $acc0.queue_depth.string(),
                "attributes": [{"key": "device", "value": {"stringValue": $acc0.device}}]
              }]
            }
          })

          # CPU utilization
          let metrics = $metrics.append({
            "name": "oran.compute.cpu_usage_pct",
            "description": "CPU usage percentage on isolated cores",
            "unit": "%",
            "gauge": {
              "dataPoints": [{
                "timeUnixNano": $ts.string(),
                "asInt": this.compute.cpu_usage_pct.string()
              }]
            }
          })

          # Build final OTLP structure
          root = {
            "resourceMetrics": [{
              "resource": {
                "attributes": $resource_attrs
              },
              "scopeMetrics": [{
                "scope": {
                  "name": "expanso.oran.collector",
                  "version": "1.0.0"
                },
                "metrics": $metrics
              }]
            }]
          }

  output:
    http_client:
      url: ${OTLP_ENDPOINT:http://localhost:4318}/v1/metrics
      verb: POST
      headers:
        Content-Type: application/json
      timeout: 5s
      retry_period: 1s
      max_retry_backoff: 30s
      retries: 3
